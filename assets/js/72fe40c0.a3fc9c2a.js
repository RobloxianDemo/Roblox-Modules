"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[851],{49164:n=>{n.exports=JSON.parse('{"functions":[{"name":"New","desc":"Index a new Signal.\\n\\n```lua\\n\\tlocal Table: table = {\\n\\n\\t\\t[1] = 1;\\n\\t\\t[2] = 3;\\n\\t\\t[3] = 5;\\n\\n\\t}\\n\\n\\tlocal TableSignal: table = Signal.New(\\"TableSignal\\")\\n```","params":[{"name":"Name","desc":"The name to use for the newly created Signal.","lua_type":"string"},{"name":"Listener","desc":"The listener to use for the newly created Signal.","lua_type":"string"}],"returns":[{"desc":"Return the signal class\'s metatable.","lua_type":"table"}],"function_type":"static","source":{"line":64,"path":"src/Signal/init.lua"}},{"name":"Is","desc":"Return whether or not the specified object is a Signal.\\n\\n```lua\\n\\ttask.defer(function(): any?\\n\\t\\tprint(TableSignal.Is(TableSignal)) --\x3e true\\n\\t\\tprint(TableSignal.Is(\\"string\\")) --\x3e false\\n\\t\\tprint(TableSignal.Is(0)) --\x3e false\\n\\tend)\\n```","params":[{"name":"Object","desc":"The specified object.","lua_type":"table"}],"returns":[{"desc":"Return whether or not the specified object is a Signal.","lua_type":"boolean"}],"function_type":"static","source":{"line":109,"path":"src/Signal/init.lua"}},{"name":"Connect","desc":"Connect to the signal while waiting for a fire to load the specified callback function.\\n\\n```lua\\n\\tlocal function Callback(String: string, ...: any?): any?\\n\\t\\tif (((type(string)) == (\\"string\\")) and ((String) == (\\"NewEntry\\"))) then\\n\\t\\t\\ttable.insert(Table, ...)\\n\\n\\t\\t\\tprint(Table)\\n\\t\\tend\\n\\tend\\n\\n\\tTableSignal:Connect(Callback)\\n```","params":[{"name":"Callback","desc":"The specified callback function.","lua_type":"Function"}],"returns":[{"desc":"Return a table consisting of disconnect-related functions.","lua_type":"Connection"}],"function_type":"method","source":{"line":134,"path":"src/Signal/init.lua"}},{"name":"ConnectOnce","desc":"Unlike the normal connect method, this will run once.\\n\\n```lua\\n\\tlocal function Callback(String: string, ...: any?): any?\\n\\t\\tif (((type(string)) == (\\"string\\")) and ((String) == (\\"NewEntry\\"))) then\\n\\t\\t\\ttable.insert(Table, ...)\\n\\n\\t\\t\\tprint(Table)\\n\\t\\tend\\n\\tend\\n\\n\\tTableSignal:ConnectOnce(Callback)\\n```","params":[{"name":"Callback","desc":"The specified callback function.","lua_type":"Function"}],"returns":[{"desc":"Return a table consisting of disconnect-related functions.","lua_type":"Connection"}],"function_type":"method","source":{"line":177,"path":"src/Signal/init.lua"}},{"name":"ConnectToOnClose","desc":"Unlike the normal connect method, this will run when specified callback when the server\'s closing.\\n\\n```lua\\n\\tlocal function Callback(String: string, ...: any?): any?\\n\\t\\tif (((type(string)) == (\\"string\\")) and ((String) == (\\"NewEntry\\"))) then\\n\\t\\t\\ttable.insert(Table, ...)\\n\\n\\t\\t\\tprint(Table)\\n\\t\\tend\\n\\tend\\n\\n\\tTableSignal:ConnectToOnClose(Callback)\\n```","params":[{"name":"Callback","desc":"The specified callback function.","lua_type":"Function"}],"returns":[{"desc":"Return a table consisting of disconnect-related functions.","lua_type":"Connection"}],"function_type":"method","source":{"line":213,"path":"src/Signal/init.lua"}},{"name":"ConnectParallel","desc":"Unlike the normal connect method, this will run in parallel, resulting in zero code interference.\\n\\n```lua\\n\\tlocal function Callback(String: string, ...: any?): any?\\n\\t\\tif (((type(string)) == (\\"string\\")) and ((String) == (\\"NewEntry\\"))) then\\n\\t\\t\\ttable.insert(Table, ...)\\n\\n\\t\\t\\tprint(Table)\\n\\t\\tend\\n\\tend\\n\\n\\tTableSignal:ConnectParallel(Callback)\\n```","params":[{"name":"Callback","desc":"The specified callback function.","lua_type":"Function"}],"returns":[{"desc":"Return a table consisting of disconnect-related functions.","lua_type":"Connection"}],"function_type":"method","source":{"line":249,"path":"src/Signal/init.lua"}},{"name":"Wait","desc":"Wait for the connection to be fired and then return any retrieved values.\\n\\n```lua\\n\\ttask.defer(function(): any?\\n\\t\\tlocal Arguments: any = {TableSignal:Wait()}\\n\\n\\t\\tprint(table.unpack(Arguments))\\n\\tend)\\n```","params":[],"returns":[{"desc":"Return a table consisting of any retrieved values.","lua_type":"Wait"}],"function_type":"method","source":{"line":272,"path":"src/Signal/init.lua"}},{"name":"Fire","desc":"Fire the current signal\'s connections.\\n\\n```lua\\n\\tTableSignal:Fire(\\"NewEntry\\", 1)\\n```","params":[{"name":"...","desc":"The specified arguments to fire with.","lua_type":"any?"}],"returns":[{"desc":"","lua_type":"any?\\n"}],"function_type":"method","source":{"line":300,"path":"src/Signal/init.lua"}},{"name":"FireUntil","desc":"Fire the current signal\'s connections until the specified callback is reached.\\n\\n```lua\\n\\t--// Very poor usage, though this works.\\n\\tlocal function Callback(): any?\\n\\t\\trepeat\\n\\t\\t\\ttask.wait(1)\\n\\t\\tuntil (table.find(Table, 7))\\n\\tend\\n\\n\\tTableSignal:FireUntil(Callback, \\"NewEntry\\", 1)\\n```","params":[{"name":"Callback","desc":"The specified callback.","lua_type":"Function"},{"name":"...","desc":"The specified arguments to fire with.","lua_type":"any?"}],"returns":[{"desc":"","lua_type":"any?\\n"}],"function_type":"method","source":{"line":332,"path":"src/Signal/init.lua"}},{"name":"OnInvoke","desc":"Create a callback function that\'d be activated on invoke, retrieving the function\'s callback.\\n\\n```lua\\n\\tlocal function Callback(String: string): number\\n\\t\\tif (((type(string)) == (\\"string\\")) and ((String) == (\\"RetrieveTotalCount\\"))) then\\n\\t\\t\\treturn (Table[table.getn(Table)]) :: table\\n\\t\\tend\\n\\tend\\n\\n\\tTableSignal:OnInvoke(Callback)\\n```","params":[{"name":"Callback","desc":"The specified callback function.","lua_type":"Function"}],"returns":[{"desc":"","lua_type":"any?\\n"}],"function_type":"method","source":{"line":365,"path":"src/Signal/init.lua"}},{"name":"Invoke","desc":"Wait until the \\"OnInvoke\\" method exists and then invoke with the necessary arguments.\\n\\n```lua\\n\\tTableSignal:Invoke(\\"RetrieveTotal\\")\\n```","params":[{"name":"...","desc":"The specified arguments to invoke with.","lua_type":"any?"}],"returns":[{"desc":"Return the function associated with \\"OnInvoke.\\"","lua_type":"Function"}],"function_type":"method","source":{"line":382,"path":"src/Signal/init.lua"}},{"name":"Destroy","desc":"Destroy and cleanup a Signal.\\n\\n```lua\\n\\tTableSignal:Destroy()\\n```","params":[],"returns":[{"desc":"","lua_type":"any?\\n"}],"function_type":"method","source":{"line":401,"path":"src/Signal/init.lua"}}],"properties":[],"types":[],"name":"Signal","desc":"A class providing the cleanest and most efficient way of managing events via code.","source":{"line":30,"path":"src/Signal/init.lua"}}')}}]);
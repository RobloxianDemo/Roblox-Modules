"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3227],{5830:e=>{e.exports=JSON.parse('{"functions":[{"name":"Is","desc":"Returns whether or not the specified class is a valid Cleanser.\\n\\n```lua\\n\\tprint(Cleanser.Is(Cleanser.new())) --\x3e true\\n\\tprint(Cleanser.Is(nil)) --\x3e false\\n```","params":[{"name":"Task","desc":"The specified item to check.","lua_type":"TableTask"}],"returns":[{"desc":"Return whether or not the item\'s a valid Cleanser.","lua_type":"boolean"}],"function_type":"static","source":{"line":54,"path":"src/Cleanser/init.lua"}},{"name":"New","desc":"Index a new cleanser.\\n\\n```lua\\n\\tlocal Object: Instance | Part = Instance.new(\\"Part\\")\\n\\tObject.Name = \\"Part\\"\\n\\tObject.Position = Vector2.new(0, 5, 0)\\n\\tObject.Size = Vector2.new(5, 1, 5)\\n\\tObject.Parent = game:GetService(\\"Workspace\\")\\n\\n\\tlocal ObjectCleanser: table = Cleanser.New(Object)\\n```","params":[{"name":"Tasks","desc":"The cleanse tasks.","lua_type":"TableTask"}],"returns":[{"desc":"Return the cleanser class\'s metatable.","lua_type":"table"}],"function_type":"static","source":{"line":77,"path":"src/Cleanser/init.lua"}},{"name":"Grant","desc":"Grant (add) a new cleanser task.\\n\\n```lua\\n\\tlocal Object: Instance | Part = Instance.new(\\"Part\\")\\n\\tObject.Name = \\"Part\\"\\n\\tObject.Position = Vector2.new(0, 5, 0)\\n\\tObject.Size = Vector2.new(5, 1, 5)\\n\\tObject.Parent = game:GetService(\\"Workspace\\")\\n\\n\\tlocal ObjectCleanser: table = Cleanser.New()\\n\\tObjectCleanser:Grant(Object)\\n```","params":[{"name":"Tasks","desc":"The cleanse tasks.","lua_type":"TableTask"}],"returns":[{"desc":"Return the cleanser class\'s metatable.","lua_type":"table"}],"function_type":"method","source":{"line":115,"path":"src/Cleanser/init.lua"}},{"name":"Cleanse","desc":"Cleanse the specified cleanser objects.\\n\\n```lua\\n\\tObjectCleanser:Cleanse()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":138,"path":"src/Cleanser/init.lua"}},{"name":"DelayedDestroy","desc":"Destroy and cleanup a cleanser after a certain period of time.\\n\\n```lua\\n\\tObjectCleanser:DelayedDestroy(Time :: number)\\n```","params":[{"name":"Time","desc":"The amount of seconds to wait before cleansing the cleanser\'s objects.","lua_type":"number"}],"returns":[{"desc":"Return whether or not the object has been destroyed.","lua_type":"boolean"}],"function_type":"method","source":{"line":181,"path":"src/Cleanser/init.lua"}},{"name":"Destroy","desc":"Destroy and cleanup a cleanser.\\n\\n```lua\\n\\tObjectCleanser:Destroy()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":204,"path":"src/Cleanser/init.lua"}}],"properties":[],"types":[],"name":"Cleanser","desc":"A class providing the cleanest and most efficient way of managing \\"dead\\" `Instances`,\\n\\t`RBXScriptConnections`, regular `Functions`, `Signals`, `Tables` consisting of objects,\\n\\t\\tand `Threads`.\\n\\n:::info Warning\\nIf you are seeking a more customizable handler for `RBXScriptConnections`,\\n\\tthen seek Trove, found here:\\n\\t\\thttps://sleitnick.github.io/RbxUtil/api/Trove","source":{"line":32,"path":"src/Cleanser/init.lua"}}')}}]);